<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"14ac5db6323a4dd5895ab3c45aff80315d9ea98703a88564fabc81554bb5c8d908c6b27ad68bbb2d4f9bbd2bda29b78545a8e5fb861da356d8d66062e2faedf195255c88a688eb7d33f71499324ed1637e8015bb0a26b1b1531c7c7ca809ee64d36c9deab2475879495a69d144dcda950496e199fc7789b4491580109309250bf8d132369bb2481b42d8236108783e9702db65cd74a8d108dcbde347e99929d4dde5c17f301add48494010c9dd1b8fe052dd8a28267839248fc9934d4c952e783c250089275118ec5de999dc11a8be17b37a8126dd8d77aa4ef2466c7aaf34c64d49bf7f93ced6a42e1ba0335f3211f310156dd69a9db70b594dd4df1eded893f34abe05e803d0df5f5f94eec4dd92efd88e5c0fce190314e159d42b7b2b3aef7e9ced64d7ef55292b09c6517a0aba587af49822e697f84e665e72911e5f97ce84da64d3ebcfd853a1340ce40e1701b8ac3eaf135dcfa03a57f2ca34673a28d8a50e3e9be26b3f2fb8ccdaaadfb6320d26a03d35574d0e9ace9bad0eef54f53859fa516231a6e6c590dc54de7ed864d48f74efdae86245cded10a683a06487c83f78fb15664a7d5565b4855b669998b1e1b28e5a231b7030b1dbafe4c76f3b41d24cb8617110aa14471d43a1e9b34b2b7f96569da3d3dfea081d3035268f77656d0b76566599536945b9f5f602452d8f405489a66f9e9d200aeb4de3542c4afbdf328ffc0fd53716c346b84bb3231d0cc577f5beaa827bd9e64a8c386838bd8fbefc472999bff935e2e8322b1846711ac08ee6456d47eb198be8e47f9cbde57fc75c7b8a1092e51acb32bb0edcff3a3a0d207b407dfb51eb88c16bc2e28358dc8d37b85e1e63578dd9be12c207ca53a39b7f74540e9c7456411e97f3dda73efd1e19f749e7a830cacdccb83dd8b9bf0b84a79bc0ccc47b85c334f6d04709efd81899d972182589edb89ee558b18a05e30f71a45adf54b9c049a34e5fc84a287068d4c748df7fb6119130879ef64e22404f4bd202110ce5073ca486fe77607b9159c4e0c36d98e9fcf67eabedde047c7dcb7e0dfa58ddea8923b243c90a639855c2f979ad9709f1655e1ed1807137ad7fabea711b0ba4ad2bdb453b8f7b65a20e6966dc7c64c2494f9d700749f435578d3330e9346a3251a78fcc81d4c91eaa82b4f9479002085ee8d6d538a77e450d8370bdbbc1824db2166ef4cea2c2a73eb06131fa2fb42ed7409860ef6ebb46fc8da41ec129ee0363b17857ab9731b67d61e83fbc0e10b8f77183f448ef18e21c81fff09f5729d8160bb3b743574371a1fcba432bcd33a68fea993edf38a4d3f95268dcc866e8e1c236c80ef55525650d96c4e72756fb127bc3d18aa893bf90be72d52639cd02f638bdf43dd533e827833e2f661699a6555039ed3ef269ee9257067e443ea46fc52922200bf0da7559ae63d3d37c8e4293f5543c7770eec4d33dbbbb4acc15bf019a024a0accece168153d7176f4e5867fc5a4ff38d4c11bbeca94687eb851f0a30bcaa3f510a6ee8f6c27883345e89f3d9757faaf4c2b6e76b8940ab1397b46416aa14fb9972f2b818f02b8f82a2747a145b86d1444339e43e921849c7503421f3ec6fce0542604a0c15b6e36ac1de09d43a93b6737ee9c1cbcb375f921d47146aeaac536096882776ea8c2ab0eb571a0ee01d0355ba084e6db3b527163a594d7f8428a80562bc933c8bfe031516bab7e31baf75edcbf4fc43589a8ec38530cddb21c9e086267c3ae2943c1d5563bb76704f05bcd027afb3c4f8d2b59be7ed1e7d329acfac1294eb8ffa595d8f8ef063f5b87f1fb0e98627d4227c7f6d3f9304700d66b72f91edcdda4ced669f5e8fae5d9ab612af12377f41d99cc8fd55ce47b7465e931021e5d6aa42f96385469494fae74fbbb101a60030bcc8fe5ab1e4614b66bab144cb3982c30bfa7bc5789100742a8cf078cf7df0654b383ddefa411e6560e13ca5259398d1d9767af2b2c468dfd6574d8b01b9e49de16eee2685a05266102a9fdacdbc8d1d7a3a20760053a03dbd273b86fc55a7382ecbe4c4338494b432cbfaa067462e4cf08b964d6c020c56af54e6a3c274fd5c9ceeb40f360058e737b0a40ff8b7b74d2c0aba9995734324685af0c2019a47dac51ebd3d221f06eb2e2fdb6283b6a17f7f969c45b9659bd4bbde43a67f144e328e3cbe069ab771c18c935679a51f8ec340bb2356711a3907ba9b98d4a80288809bde32a47cff1e1b1169cb44bc788ed817563ba9a55d71adb51fbc7d32aa2aec0724924d766d6dade986cc881c332884ca394c8fa01631ce3c8be486991f4e285b5d806f620c2de7d25944de8567740a7fa662bf61412153582e2573747080babcfc59f9dec9e068440d8598c98d4c013efe19f8032818a1b248b3dd6d103905362d2035f0705cbd88f68672c63f9f90477feb65e8547d31d124deef97760d591f110d319fe4ae349ab6f4499a57e6f21dc0b586720d3b7bca99601a8949423f7e06181594452dd711b9bea2cae87e33764733974366a2f216a1b49fab2272efc11aabbfa8c1d33fc0db87c91db995ddd12889e5e4abd78c4daea1c3355c6f339f60d332811281793d1705065f3a75e0bb688007e188f286ba904db7b4b43886af42a8819cecbd02b5fca9670222b9fe37ccd04ca25392796344651ba9d5ec9cfed3ffc286b487e15bc9da24b4abf7eea6b06e8e4878380bbc39db6d4ba4db8e53a73ece69401ddcc8e2c2f4e7677d3556f20adf900e1274e338fcd2143881d05ec965ec3d4b7f21ed18493290bdb11ddb9a866754184ab68b1c04705beaff2627e707d3324c2caae78045161e4c3478cdb87e4472d9c83f4dd0922a3e15cf3f5c701670f1481c9f20353089ff2a24357b3b8d27e82e0e663c1df16b0bd736acca11bf047995da994d77e993f5a8ed27385408bf161607dd8a763d5326a8e5e7135f663530dee7c727bac3f1bb0abf7bdac37df1d3edb8405c3087f05c8da66e4eebfa0f669f0296cb0c6aa32226364a79fef9127ba69e73e1ee5de5707a2e56d7decdd0c57ae48df01c25a2bb2c977626f9fc6ccbc149894783a068f5803544b3e0d4f2b9e71ddd27a09213e9bc61bbe85aa4953f37a7b9a3d776e976653be6bb81ecf284cb8f0002924efbcc784b5973303969e9d5b21a3229a6ae0fc4e7504b5738eb7c6783a8fe5d0d68ea99b96af762d497302b16155fbd83ea9515c318f8d8e8ca66806e0eec5e5d5b32b8ba3c8b37c03fdfe99c2512073e55ceb875629d19a7c388a717e31c3ebcee0bce4e312bdd1e6e87cde56f71dae72a70d81c41cdb32c09335e5a3d801e11b8e50150c9ca948dec068f7f43dcdece5be75035abe36ed4510d841771f913b8d2e061a1c235ee36f66decc0f8fc7a5dd0ce5a9f9b4258ddb5576b5b72b5680174337c93d505fb4b85ee0a62ea04456f0e8712d688921c879e430da06068fc2b745b45f58874779225bce4162741f635ab558ff23b7770e3094841828d11e27b78d34098f9256e2b5265a74485bde46dd99f8c359a6b030e26572c4f8691d8f22230a444e317a24a153b73f44ec6fa206f588c14c9fc88192b9079126ff8c6906f4fce06ab40fe026de600e398c85dcd4874c81740e0528a3bda85d0f21d9c73283656e0d0d2ad919bdbd89f6135d10781e0c56c4db3945dfd5f33a16488a9bb63c4ff9f4bd4f241b7e3bb0b4f0e4c1ba78f018d700640d8c53d670aacb59328a2ea0b58dbe34d7e1a56e47ad84d2ed6204b5fed40c4577a4e5bdf75e24d262137effe8e6356ce68b98854da825c92346779d3c92c4f55c9d0d1548cec67c51f1ff6884e8e81697b02a534d78a6875c9e6d40f8f2a3f2c970f7d644e15da6b4869b66cefb0fd0d6e77b7daa609b7349da84d841692dd554e73b3f5274f41d46b3e455f51f53f4e6083645f6699799a32fa78e65f1a4b2b698f50be5b1ba1578214575f21a0d4bf9577e8d0c8579edd916ca14e343f49d5af30067b7ce6034f5377f4c9623db5e7be637dae9ca6f75eb8ff6f4ab4e5f9e84af650d304efef0721eec51232deea5464393dab2b11804370fd6fc46a7c11d839145c7dbffe202811ea0b6917a3e89b480b3f1fecb6369bbb86d77758d784b9d36df6ce6f522302c23346adb278141e9dd7fbc5e1b5a363c5fd5146c431f8950412d89f0838334fc9b23e205a6376943f41aaaa62707c5cd0469181ed02edd5de375c616d7a3fdc8a486acd89487f21100acdd14bc9b81a2dc7f4e03d022e8589e48dc9267cd3748e4f627f8242af3476b4c9e0d3093baefe9ac03f757f4bd022879ad8fb7b1dcaf906ffacd8bd06f6b19da69f917c741c778676f7bd7707d61e932212aae8e4cc576aea53b0b440427630f5affbbc3bcd3077464356083ec8baa18f2687d816be9ffd1b3392b05f28f33c78fbc04db18158957cd111213ff6506af6e26c4c517080cb012e929b867fb841f30f979a62d15d5037dcaf60f06bfebda68efb16b80c9cf9ba7faa04e3dd428f617d6ef6bc0b3cee83d58dd0835f8213bc17df6d2faeee674e41fb5987459229558aa518373674725f97cc9d05e57469e669a437e557cb42b9019eb5c0a88a0eb733ca0e27d94f6bdc33f3629b6b31c2df71c472f1cf2fa602f78558ada33b2dd62da0de0844cda1bbf3d85d23d6ae65a442263e4905e4020a76e051a695dee74a60e4c0c03adcdd4373cd5f11c39a76586d011bd7b046e314defb8f884d17b4ccecc66e4a8261cfb808addb2079069b8157458d36738f10e7176c5893caa49456d4ce7d346c3e8b7e894395a4b38e4615fda277389d35b3f93ec7dcfd67ff5c6bdfbde8ad5329f97f12ca8ac3a4e3e320085016a03a776a7aed20955c6dcce4a59d43d50437e9413baab17becbb4eae66054e705618ffbadd34c0f9b2f52c8515cf4fe1936c60bdec9ad61fe9c3a8bb7109ea28e6f365519a7f7131e60c878e3456c23b3c06c65a5be78769dc190d2017fa9e60b72aa8db80ab8349fc7fd8bc2d52948ac4729e80a45471961d056621e99fc666f3617556ab71d016a8f4321112d0a8eb695df1f316402c97d809c9efedf13a03966d8e53dd8741eda41249345e80c2624eeb52e9e7f50238459f827d475f011e9c829d572c202945764057209615f89afab07b9b5763655c6d4fc15b0fd4218231f827768561778404a539441592c9605b082ea59a0b6e5af9899685885cd96ae82164560eac5c70980a22d249b2b72cf8ef9dcc053886400a345358131f987b030d9eba7d1c56e4bbd75e75e457c73f24102aed802dca806a2d9e7d4b7ba0c1e3fcdccbe2721f07fdb8f00d48a4e810c004470be0eb43fdefc9f5580c8b9c01d134358c0f7d2ac61a426b9dbd5e6f2a9cce843c8b489d173c6b94d890953776ac9bcf86e79a8076719c5409e7b81d3f0bbd76c3eb483aba075b728e8cdfaab8790801a10ab03e1283c7e93196c9939f3c6edc8bdfb698cd657865ef15fcb46f3588461898de3181878fe1549c18629a4f37e96bd0bf02a40c6d22b5134b0567fb84253b6db3f5e23e1de5721f7bc6f85866b87c8753982e804fe9d3c22d37123baee9112e733af16c55f167502df35d333a06f623902ed04e98fd864f0187367315e228c8464ce25990cd99ffe08babe594958ff585f011091af9cd409a37b6048eb46665e452fb755c4075059fc29ebce2060d44f0252e68a9055bbd45fa5ea6066132a4be77e4a7adf9204e3b90e93a5c1ea3b0d4fe3fec554050519dd131221e00cdbf31b80a1e673d10d5ccc3974f45dbfed31dd721b925b01629a847ed53c6e9a1b12898fa2f1164254f8b3ecc0a1b41ae43344784a19217974477d2f9ee90940a3848e79bda096bb5a4182de00d50f26e8a86081052a30d829b019a4b5fff51decef955a7be36ed2be41f3abf8bd8d616ffadb3103f6a35782fa3c8c88e93609c27ff2ec8934137a1db5dc597f028957843547b93af205582f2e66f1d3e15c512ff919c4c0258af796b3d9584b8688178db63c33358099fe7249cec7d5fee462810356b262b5dc2682ae12f8ed4945342b6b9e59827d6e1c7ff32db3437e43fc9de79f9d86ac16d5163d392e9b932c4e73178bd1ad94caf9849c020e1294bf671a70c36ca1a69d00fd09561c2ab75e4077b7138ec469d1e5076ea8c81f8fa93726afca47dda7c533a0efbe49fe46f029c32dc19352027a3db5d2018a0cf172b2b87c773ee99d590047e4a94d28f409c32605159b28b5b22482dc28a0c0a2a530cac380aa3698764fc53304b6d385a92ec03a855e9f9affe11476dda66e83834a93c49fc0e93f0d06cf9d10db4819b6d293567463cf19936a9261dfe88dd3a3b18e483b3d7c38bcc2b7bf9557adcad30a3b6befc019095671f05d1b8418abe53a687c6830cb6b8e55b1e63ed9a53fa2c8fb012561dc0b4ba1c0fe6161341c0dcb134860c79ffff15994f31543dc14f4a3d94cd0bead7bd59e9e80c4716b55fcbcefc500d82d741f41654e9c6f816ca5b01f31f8cb73df4a6d18f0a5866cc945817849a5eacbaa2ef76ccda65370dcd15c1d02e0a1799253d0f9eedb5a08a4c33f99258ae1bf861d42a6aeadf197114f1d524a3690ea11d24ed247646ddbf4ec2a62c81b6f3160b42a5fb2110397ae24c4ead397282f164c8609b6eba4b8627fe73dabe329fe82b5510ab744161972cd41f643cc7b9057505b0fe37fdf79419411623fa5db5456d4794eea861a7804c0a7349725c95245dcb7f6a31ef3a1a739b013aea49f23ec3ed67235b973050c0c1637a704a524f384c23894433c82daf0d5325c45b55ddb48a66e4e888de081774b4009d10f1122caa052533bfee16a2d73bd5f068b5b5291d9f60db646d0f2434c2b8d33356f9ecfd2e969dc759a42be054a3864e108c5b9bb85604e664bb5b7e152d007dfee1abb2d0f5ad10f95d6775a9fdfe650cf21ee28ac13e578af407f4871552732e87cc4f513b9cd6b41d512df64430fe66178069316226b93ade81964812d86db9ba770faf7b117b09577064ada1ef9ed5f44daa7c27f2be17084f55fabae6992f54a5c42dfa02deae682755866b23f977280d8115d45ebc72137a7a4175ab08d03b6c4aea854bbe0daffe96aae987a0674ea99caee242d12de59d03054efc50e34d919c45d165d0502dfb4d7f76b2692116e88deb027b65abce957461440a8cf0a02c4ae12a130a92cdcfb87fbc0f45767e61619f91dced0d634abaaf84385887ba95f1caf59c7a9b99b5d87714de119ecb20fd1c7b23ea1cd77db7f477bb3e186b6b56db3363414481df91a66019cc87dee0571c91e625d44f5a04b69bf3dacd7f2d99255cc1514b14f75652ffbcc5a5aa772b50f5cc01beabf4ad82825e79f866f8faf743897b3b25da674ab5253fcd2d9367cbb35866bb55a563a2f90ad97a2c197aa8eaebec0672933d8b4994271ceee2e1f7ca67bae34950cab52ed79b72b8dbc8331f07ee44168487fcd7c0fcff36b5363dd21d687372734a16c05260de2eae6e8a4fcc98f9191231207c2e3584461ce030643b06937a6e35ae333f03873b25bd503e7e1190779aa17d09db2c21237ad6b96ccf1bc2e0cf26d3354bff9ebb76bf2a09a7e6ce97705e23daee69ef045b471fa376a50a9372f68f5ca535eed887c8e0fac2c373e2f216a16194e8637d8e640658874e276244f6b3a1cf83068d14ebb28aca5bcc73674ed3f439b2234e9d019c2191cdc68b4b2445b718588c09e55c0da1a7f5de1b5455c94681a5c29ba03accf9e07cb82d64560b715b02c8486ec61a22fb7b339b2da81f0c6f2a22b94f5139426f0e37b02972cc350b49ccf3a8b1feacd696f319eec6e21cbe6364e59527286cc7f27696886eb3dd86a0fde29953f9477e2dbff09dd002f2023af6bb39cbbaa8ad5a840e5b4cc71a57591336cfbc231d90e99f0709b4e953f72423f657022a3ce3c83988617d1b66fac5da73f264fd0402a7cdc8957b2524393432050c305953dd0fdbd81a8bc33b7a0ede337d35924d125d16d25059b4af8abbb576027f9e7b039da543c726c808272014c36e696b3070399d167b7d3fcc30121aae87b959b05d9f243b4071035a5de540b576c0af6b394092c6af92c96bfd75b815d1303165a260cef974f720bc0fc1382ce1e9c0a0f62cd2ef553e81f95581338d7e5f3e84b2576e5cda5cfb00a541d52acf62d3bfc18f0460e679908173cfe6cf366ba4940435460debb4f4c9cd518c9c500819557e22954591eae4d0a09a8f3c6a5153aa29635c7d81c65d116ad7a92701bb4c3799ae8211054107d86f5e2a73be2c2e187d1afe488fe68c3862ba411ba26330838a347ad2b23a71de92b4d480ca79f481211a392d145d5b1d3a949ed67512e82b51e13d00f06d897a60ad652738951e9d78605cb506ed70ab18ee90c8f127505b84b6893c3ba386da88eb7a9756c58b5d817b494f49ac6f0bb6c02f18f96eb6f8be2f4b0f9d6b0cd33227d7bda87f09b4ff7235d6013af4f67f12cb19bb743dea1a0e476cc6db369e086e1d74147aa4ddcbb4498848897f3e2a3b1d3f41d28af3464cc91ad1e040756b853788a45899acb47e3e5390d769dc5556e8236870eae572332a90690fa877d6853d4788d3c50b754fb899079b939dbb691452b638303c2e900855bd8b00df4817de0994bf0424f3ae616c51c8889a05d35051b8d5d6667217fae76614f4bd96b9bec1711eba7c065ff9015d599131aff344ece1217a9a4392556c65ba12c40244783b48c57ce183101654c8b4048849b096d128aa8e633c7b5e73b1d109f5f04fcbca75f148b23bddea07c1e65225c15916f8175d00f34d3b6c7e7a8f71f6eed749f5b8d0afaa7bf340425240980b7cfaaaf0845a672d4f0038ee748e0db49936ee454a63f8de00143a1df95a0f57ae1f1d295da6ce70ec3e0e77f760f5732e866ba7962dde2af9cf491717f0cf63863aff6d26016228060d1e205f55d343a5ef422cf0942357c92760c8054d2ca4838f120237e4be11359a45995c5e7731ec3a25f2aea3c835f2753788c0109f5e5d6a2f286b109f371f607bdb0954ee63f16d35b4c42836cbc2a31efdc8d0e7e196dc0400401c13ddd6993991fe1288668658b6d03b94dbd98981c8726517f7e640a4d387d962f2ef602d49af98f62e38210594219c94dc841d59dc60d15ec0112aefd18b1ff89981e4a2c41ec14b5029ae7387ac80e0bf5eeb4aeffe50b34faa4e1b4a7b6077696463614d678fd92980eca910cc4855fb1059b4e320d4d3720436d1a04f27216720628fb5313d1c057eb46e578cbf1464d3f32d3338049054373153fcf904f3db96479132970bda0dbd1b8db6033647901dc448e88fc022acbdbb94d3a23e60b33eb3b6dd9e2ac52c682d3b4f85ab56bd9d5f90e797e0857e9922623592ca63fb4e7045d9c6e41dc7a36be83b65d81454ab44c6e0a19609218c242420f38a8e311e569121f4c02a62ab0ed971b8e764098f057da3314e753ef6ef0f697b472f3273b2f4978e15d6ea3c179d3dbed10a578b5370e3e528bd038259536c10cf837a3da7e893aa21071a32bbbae17fd31bd8e93fea2c9b2f7d46bb81ecdfa7d397b2658ab0cb4d242513378efd5047e610434589b1fd6b4adaae2301f27cd1ce94a70d8270f144920eb6f939b792692488dcbdaf97e5cfa2f73619c6a7f30e1b9a6fb099870da32d6c265453fdd8326be114cfbd63da829b854be468db220dad4deca4cab0a73b6880194906f0d2eff43fd5d431ba89b68a300b1a9694a091e06b334d2d9ccfa59a9239f1c1de0e8fde20aaf6689491bef3441cd3c67c4b8748ad9e1aa0e8a5b9aa724801563ef54f8eb8fbb1d9f3ebec31dd4f0cda93841ddbb0e8c5b8592470221a60e09165bbcb170c878d48804058766c59ebadd89686ec5c2864c10694a13a53549b34aa487094f69a93623e31425e68cd10dcc86fad83c0bd85865a1315dffe6e73a331e49b5f55c89866a38df759666471cdbda20f3b9b5428e22c25d83832c04308b19a6d37d76dad070fc982ab75227ef01fa887f9753d7c08c6c6229a1aa4cdc69652066a82dafbc0b3ec4ff83622e0df8bdb23747b7b7a7d2b12d2f3da60aa30aba5ff72568ff6431bfb14f0743325994b5e9dbd0ebfd16110b812956bbb6ba0d07520d43e0bea31ba471ece29e91295f0d7899a699d3e339d4d426c437aa8084bc4dc0de714c94175a3027798c4d34cde8b5f7a5b06bc882664f55ca600c9b0f418415bfcc5e9ed446be8215fb3c6f8ff8be105d8dd14838c9a65d88928c4d16cf9731811dedad849b8e7555e7684c11e1f49ba13baa439df0919fe02ad45518161ec66c1ee82c941d1365d1614b5996a60cb0a4bf25e07a41726766617ab28115c021adb2f248bd3c0c68c451fcc92bb2447c28af6fbc67a55c52be2ee45ede551d9fcd68fe21381017b9c22dd515753a03603375db2d91deced629fa57ef6842180bd455f7c97d9950e2ba56a5bce0f43ebd0963f28c3a094b18208f5eeecfc851cc50159114d9ce0e7e3aae6ff01f4692c16b9731e6ecdc7af2576dba93452781e4c22727ce675322a6fde910c33db2023ba28fca71b6884c7b36f3a6d119044e239a9eaf06b14e19bd07f48d8540ba31159a20214ac0defdbf51d91081e83d164e7d58ad4d2b1c860f53031069b43616bbdfafc21197ee68c19055e96ecfcf55972d1144358d19b7b0cd765c68a908e32883bedbbbd656d8cc537e17c1e2029afbe079f04fd7fdb85d60d485873114c838e63fe2dc0a84f2beb3c0919f8b36e04a56a7f9609b7e14a33b7792b702d1b1f3b505264f3a83cc59d8799817bec5454f116a7f22dd8bff2060afef93b9e2a152fe48c466dbcedd158ec2a49904e437bc2aaa880bbed06a298613d0d3c27fc7a140cf4b4e26b4f6712fa6c5280f12e7c5e920955aa4b74cae87762a9def77c6330f64a34df77e798fc363dc035c3d2d55cdcac50d820f561c13f4d90f6e4e0c434724827faa1cc290ea367987aabf85fc9fae8d135f1f9d73bbaa13a9e6609dc53bf1db44dae232237befbbb6795519a72418e19d48de1fff73e7f228a193218f163c3d60614d8debec74a7121a157f3639580543514abbc6d60a35ff94ba3b63093104b5ec1c6f0c1d1782af11101903e0a1c487a4a083e58c22289d9a7a2aa608912cb208d4e6e3880923468a65bfb772634330adcf792f57256c9bb01d870a75d4214b397c611494283fa9e1f6af4acbf3b54b940acd205340ae9c873e991c584a43e03621411cb90451b73a9e6abda54dedd217d41e0acdf3d6d55f137918ded9214c42daf5d9f20e6b554f9bbad48ea743cdcff72176bde4e8909f9f050c79a29ac0bff2bbb59241426f5d861a3faabb3525ff989918e3c77422bb722fbc75d0bd9f4bc6f63b586f67cb37063714851e6dab524aae16100fe7538b101b685f8675614a36f468cf55afb1fb3cfa9df8b914ac3c88d60e6303aacfa6a22eb4452d9840b03004e7e010fa2156dd7f984260b721205f08d094f1138646d55ab20256ae58dc60acb1d7338203eaea70bcc4a3a8e5cb863c7797749939b7fdfd387b12d5f0cc9b387daad5691334f087ccc463e7e4783e9105b0f6a1f517fb7537cc77e1b0f818469aa7847f84986609c8e0ce33694ec31e6be84dcda874786f9bca2c9f1e48c12abfbf062e309508d0adca5a6d51d752c62944e77680b8510e0e361d734af97d56b96d15853afb3fe0f85c3de23421d6b7051bc0a778470d0cd695f4423529d7115450a268d3c0ae3777e9d63663016088e577d3f9e10917724bdbeb32c85dee69dd839277c95684ca201a42f88e05bd0a5fb94afa33f500d387172115c8bd02c74ddd117b9d0eb9e5a35b19100c6049acdda752fe60b5188aa2326acd196444e32d608b84c06fcbe6b3e9c90f6bb97ae93048ed6d964a303fd184befe74d5a1eec88269354aee3e647139f2bbfc45e2c01bc2e864246cd24ff81f7b2b30b63605bb6476a69c1e3de07f57b8808587c19234e2b0325f490704f911486061710d4c8e7b6bc92b67ec76fbfa5e0aa56ad5fe1da692a8fe47880714ea0e82aae97c3982ef62c6c9a0475447e62b5e87a28128dfa3e9540f236be952a66fb3cc103901ace5f8ba9bdfd322f5b6a6d9b52e2895eb09d9b22e218ba06a0de054809356baee611b77bb5159749f49df3cb5709fe5ff2448bf0fe4d18777acbfa89dfb3f5b1dd93b1e1a361919a8ad250ac55457e37a58fa3d3b36bb94f0517accf2e987e5dce3816a7b6816217dee9153730281617008c7d5d09d60ce2b115c84057ba174eaeeed1e2c6e82ccb360e5dbf85d3b8de0fdb83ab1cda9cca0f9d37dc5d967b9d3c015f5c6401e4a510f2a073cf4835323b574cf696da3a5c2e3c3388cffc18ae14552a4e7a0d8f0ce7a379d0014a714c56c82716599d2fe4cb238a723c56060d25578dbe98fb631a32613fa66c3109ab9ed8d34ecae0f0bf30f85b9f4391acc9e9aacd9dc6732a5a04213e78440de7304dfa5f3cc2eb6caed4e98532e32ac4bb8ded5326d7f16bab532a95e4aa194c7a57a1c94b7417028ef09a27c3a4a8302926503341caad1e1aba285fd6614fc59711c0dea308dae81e0826bc559e66655b15c18d872c88358bb0b67b2e21c872b17f1e4c4846159c64ee7aaccb7d279890365b4cb852e0086f2aea948db9461729091f7d7eb32ca0470a9b04f8466fb8372810f5bd20b4215c2a78e5068f3dce8db89dec8d3b429bbfebd0fd3320d863eb4b7019359929fcf930fd47eff9f9307b39c687355d4510d7cb501262470ae058f712b6b65625e64ff60c4bf45f33dd5acd7aab2c2bf731c0a002f26637fd5585037f96bd017561a31a3ca3843e0248e8dbd81933b260e0d12822ac6762efdea700359130e4b7034e66b622fb413de6b03d59410290bea43b362aa3a15929c90ab654b2504600e2de4106b505d8d6f22cb6956b9ba6bce18dda36cac6bdd595033236f01430cc95b9e2d6a1e4fb84b2c92145f8a1e4168c6226b37b56ad7cd9a394b3e4714520082e521a6d01a85f3a5ceb324438e45899bde3d28cfd6207755da6bd24b46e9210992243f4f9cc8c3f98e755ee1143aeaf4de2ceb4c1c3a55e43df288471a9b9f8712a6f8d3c009717bcb4b1d91001636b30091e17763b3970765e8b1a157e5bd87fb95fa7760fcc23e46a44148c75160e9d8c4515a7bb4724c35a7cfd916dcdfa006f87ea106b2f97fafaf7bdaec144971f3651416594eddf4d141f18c3bab4461c8207774110fd7253ab2cc2350c643e743e7df80d8211b4a98c95d66befd4298c19dbdd88c0bb0777e449ca9599d046a687e79ded98cc57f733f9fd13e5adaba732811ef34394738a9520aff560426cbd7c81a907b8d999fd51c66fec73a2871ecb74f62f0fc38472f09cee7e31b2402ac04e7a8617394877d7b6ed6392de3e750873a9e4bd4d8bd60fdfa23fd9cb5cd5b60d9440325718d117910131008c24cdedcf6492971d98e4b0e2e194e8c53dff2e087b0b64e4488dde93111a8d5e587aac45b4872335d8b2bbb876eab378ba00625653106f9abfa188704a78966db4bec10c560f4b7a7a80b1884ccccc9ba95c94551d85b18de7613b8daed1f380d14171177f11528273a77957b8622e6b6827ba5ef39d6b626a9538c4bcd1865bfdf2f3e93bb6a959122a79b66407f299d3a35ee85c97af73003f754f3671ad458ff86148184da7c7b46f4ab0060fc08a70fed275ab48813980020581ab1c63c822ffba7ae77bc802e97dfeb2cc11414cc4942447cef08cccac1e8dc091e88a788b94a107a85a3bd3070f0605c2f5d5f5b49fced93deb2f59565ea48d5544a270c1f49f3e6482bc22445c3cf69e57fda7c982840252f53383c0f8a5599e5e6f9c3719fcdcc8b1837ac652b4b8362629df44ee401041f5efc778e452be668b9bf2ed1941ced876c73d6733efab3e2942166d5a66e43fa25c973f7bbd7061199574afc4a2a1080fc71d872b8f32ab624b204b80ebd22decdf482f869eab2b1813df63fb78a16ce723df6375973befda29819a1884beab9bc58c3c8fdef33a829072592ee8683583b0280be4da9ab28f7f345b0ada81d38f3ad80f0c5e716ac8b897516b01a2e1b8ed4a77394f1359d10636559b750df258fb800cbce5cab5f5a0b9fcb0f928e0db5231064f78ba0b7f05aef24ebe67922da221790367f01efa84cc54d65a8da39b6550fc223dfc542517341957bcd701de2ae5b070d3a1fee7c1be67f9cde9c73536b1de036bf25f6e02eb14b38a21e9a20cdd7ba077fe9a23fb0ba3561944f270f1ba7f20a35f3c4a2667a2215f2030c30e77e10f27fef295eab0b97fbe6f210496bc082e50bba82ecbf0ae5c9d83962ea703067ae152b6064da2101e132defdc59121901ea2711d8a1dac6b9735ae9510530321a6a70693b39c4489abbd8f073b1221eb56b5a76117f70d01c0791760455511f4d03d6b0a55fa49d11473d7475a3a63dfc5af67574811532083f8dae2389aa09a95fc862718606341fbe7451c5aae40bc2c90545052bb723f9c5b87e6dbe8b5cbffa7635eb98ac52abbc07dcca74fe0fc297fd126eec2f8ac3e9f5212cb44a6fa03f36169986d97ac7e23abcd8b0312955db91db2d496a12e643a1f994f8dcdb3a2b2a919bed0803791fedf6290e3a260efc719b4b9647eb33a8ad62a6291f64e25c63b0d7f6777640138277e6c516d5d9b526f21b80cf0198459c65e75e84aecfc484c754779140099a6bbf108a6d6078b0d81479f1ed4ab1f69baceb0920290bfd708bf3c8478b3b0dca474e626a54fae419c289489b09422f6921303fc8cc76463614fcde16e3e6f8ff480dc078c1926baf8d2d50a515ab4edd02fafbdfe3b30c2995718c0a95e9a3132670f05e67d19f18a6288dab8dc422c6f9deff4f46320643cf28fbc05d39db8e6f8d1cb05cc47b60adbbcb4254bb4a453b071a17355b3083cd5f9de7183af042b8aa19ab2f66facfcadf034b0d6eb426af94f45324a145da9f1f1fbeffb9d4ce91dc57a5950fd8245345850d030694002ed6f647b0166a6e3d2908169c162eb012bf03c10f25b070c38e6e4e3ebf8900b78e265e4071893d066f7dfcd7f471046c2876c6867cc3431779ac01fcd2324692a358b9f13c674661fa5fbbbcd6b2feef103573ad6bd6b57ce5dd7933a3642ac7658416d1fa91a3cb4e74a52f00cd1767f8d7f32ae2429ee56ef38b10a72d37ba381fe0b6a4661c61f23ce984a961248f94a9d3faaa87cf7d63f9e0ff74a7809b7eedbaacc4bbbd2022f287773fe3a432d998c513051f5c619335e55e3c9ded19d5ce74b3240a7a16bcb4f6fc617fceef8d53e606208f7ea462794677bde530d547fd0bf4fb74bf49f26b6404fea77dffdf7d0224a56ab0c6559d2a020f84bef2435e652fb129ac0d41ecc8e363f39b176f864b83687ff5585a9547cf227c5f256bdd3070a927ccd7add163aa35ca254f82d40dfb84bc929cb7e42b3fa433e7a8b1486d01573ea2872cfa8e239220386b481051ee3a84e84a8c9b5c97303af7f4ca701c4c9f26b20cb647dee80d57e0bd233896e0a8e7ed195c8604baf133b6aabe2e93d2b68d6a7e942d3bf42dc5384fc3ebc02f4cd4f77be4b0c73dc9bbe149be10d15eb5f96c0f95511e968bdbfa4015713087785be9f98898bf8bba6a2e5c5c0927f47396f8da8344dab9ec2c1fba1dc3a096b3b81ce4c0858e5283dc3845e4dae94187e37cb0c28fe1909f80baddd8e87bff59d35a9d53365d3cadad30a603eddac0ae3d662a0bd89d0313bf6effaa6d4a9b7c301ab82227c31addec606e43256ef3eab7ca09767c0f4527dc7031e669f6409ecb9014156021b88dd533a4e4a9b7acd38f7348fb33bc90ad96a4fc6b4ca68631868f8cf165fcf8106360c141b4358aeed4d066c42aef86d614bf6b3484663d204a6226b9772a6cff652444da76503996f6ff6264c6aded2f7eae72c351972111f3393d83dd78bafed95da7314dbf8d4a281deb2d4d4735e116ba4d89ef07341c707c25e3e402ac00bd10980dc3a6b65bdb3806cfac77a70ca52d66d2a1d641d8aa1b140055a61a98e0930ac43e951466d403b126e7c67f3319b84030f857f185ab18d6fb1bb972cd6c612918ef0b25cb275d162e5847093789c294f7a67692eecba7f5067786be5b602c99d214dfc00f2299414e884ec459be3964b12ec5ce9d487fd08efec67e14e306264f3303130125685735139c246b08bad1ebd6e8c9bf40bb6e7d5b9f5cb82fa7065fef1c2b0864002d0ac7a0b510f6f9e41cc809e3c73ebcb27a4180962d714e58f46209e6bf7c2b25a5f8ca5ee0eba19799e3fccf2713df884d8cfa244d5bf4fe9e5b3ec1e4d5b08e906aaca5b797bdc1b43161114915f10fd389af5cbd8c76045439561f46c6112334e21ca7f32db543bd01d5081199f1be73848ca87c2ec4a83fe218f1c4b2c70e3820515574e02ac38e603e653381cf8ee7e3b65f05d8ee2c052bbd8e9ac91d10e1ced5a6ee767e496fb01ef9537f5dca9ada18f3f54211cc920a4883caa7e586db7b8d3b4aa9ca79cbb2b487f34f7f1ec96fdccbe801201f0e06c50069fd7c9c87f5dfbb734234db2a355f83ab5d6728ba46d1ee9e6abfbcfd0bde8870c8d747919e926cce635ffb8e0f8d260c6eb85d7b549f4175b3b043734c01b82d0a8036561037bba473c76e395f3386eb0626addd418530bf7510ad06ad2a62926f5efc78fc7531d40d4d49fe7c9b46264591e11165fe896250eae14a4814d2fdbbb48af5f331460e75d358622ea2bc97847ddd0e247cb37b7531167a949fba4c0273f137bc60a7b3f2abdad4c4002478647c8880306f2f3023f946d2a701fefae0d105c1795e6685ea7ad803c6e20a63b3ae80d8df9603baf2c37905c10d3a8a5fb4d9b8c76b620ebdcf1a17dc04be80bf1dfa694d5c61c2fdf558f287dee5aab1b5955bc220a0fdf7e43b4b914f774191b326c3691acbeccef61b084d699f511169d9a88094dc672069e99dd609324a774571a096c0ddaf4837109ff3c25ac1141e8a03cae8f6c632702cc94df26c52baf0a8a3e8e5c284432afa6bc13201ee0ec65966ee69377a1090c57ef7ecf569c411b9230a67cf0d29b8d5829c7fd0a9fc21e6fe7b2f64472d76b6bb8e452c2eba90b0c8dc3e9b8d2a36ff4ad421df1cabe2a2944d3009cb619541cc811b4bab25210635678d0414902b24dda769babff8b7f70bd44079feffb832066e473f0bd5d43954b859fcc3d98a8d4cc17201b45fe632177afcd36b7a374df65d81c07b57468ece5f89281e8d4e2c5891e2e746d7ecf4dc5d7f78695c5990d81f7204a14ead081503ad25d33964248cf341952da75e5ebb140a6c7a9f52827d96203cfefb1e44fa665a68ce93bc55c9e409538d6398edbccbdae5b3927895a232d6e6de3627579881bd176a17c52610e5b032413e615e16cd2fd38463c29ad9e7f3762031c62a423750ed9a5f414559a733ebde7e3155f5647073f95e0e3d6103fdb289d3093256d49541ab050646068078c2265cba56bcb366cb51e9d4f460df247cfd0de5bbf514d8c203e64d7d9fc13ecc3de6c7f6fe1f16a4de0283c393bd0cd2e9bcf49fed6010a16791263161f0bd5f4f7557cf46227ed3874334d154ac9a21459448cddedfb97ef888fc475547fd6af81437e26b5dea6b69fdeddcb94e4a1745b74382ab597d1cafb99b0f0333e6de7948bfcaaea92404f8cd49b6c8c3e43454f52bc02a0b0058a7f2810979d531e47af881d52868d3df04d4fd87fe6a4a812449d87162b9e9f0adae50d1cec2ad2f74d4ad2259eda5a2a108aaf037c7b51ea3383beff3c4f55e0e5cd18f5f132e024579f2101910974716f7b9dd11550911c6335008a43b689c4ee1675221e487da338c22fd5ce9d917403a5b7b8b486be2857707311afe0ff89d0a356593adaa6d9a687857ef12566e4838081866a4667c9842f8621abeb487f975cd20b2d59cd0e12a5c72b37fbf286f989a73f5283f76e91239f15a6cc8d3138f1673a87cc48a21e81d97125ddc4e5f2c87541ec8d79614cc1413fefb9663dc09a67836a7236cd0bbe18c57ddabc2587b91089da66f0febb70c40180aab3d188beceb77df57b24608d3e17d0b31aca9988083955cd50f0ecfdc0c20a0122bbeb4549765176377d8c07177ef07673925c73a38dbbf6d8d5c3b4068390f16844e525188506d6a40a25d9e2caa5c4818cb39d3872fe64d51edb8d9b4c69798afbabe95f9fa61b34e79ce717b07944ca222fc6eccd57796ae2836db65934fdc266fde81441c4e0912910366ba836c595c391f32215c7cbefbdb34a3e1cdb7b63e027786bbc4417b58866f933b311f9a2824ee9a489708bc4d91a6749c6c63a7812603ff8f9a73cf7f3ae55628473e4e1008594351338920124d5708c29b72f8c30ad9cfc6e9bce043daf3b4a8170a326c50d6d40c0f5f6a6992a01b325d1ef6c43aa9bcd1e57935fd494636b37c6629026d6159d5d36a25b787446a0c4d27bde2d5495c3e815fc9fb4f55c9f2c3e18148a6ffe63a7016301c57bfa96e1e463ba78ef21e5cbe68dc85976fd5eceebb0058a5d3ab2f61d87d6ea5959f367fd90fd711de8f8f04d87e263132b3b1f9c985f4d50015f6da1287296ee46a8cf22647dcae4a059ed1ba4676424efd4bd90335df317ad9731f1bba4f7c9e50f447cce8e0fb4664ba8b2cda318ca1fda56d30186bd44d9d9572b577f99e9d299c37c43ca2b6ce6edb388536ad1b8532107d032fce8bff88463719895752c327b2c1db7b04a7335212783b25926e835809b1290c6d7c9bd578c253c37bc84e5c78bb57b163c1b21dfe4fa8ff672fee8b42c107d3e52ccc57786fb1cd3a506dc5035e89a88584bfe7758b12864cf4fc809f7be5c8b4de1c72bea9d8ba1a3130d1c23f270d5a21900f7da338455a2580910b62086b78237ad98ee3259186a6f2c5d19b38eddd410f90c728fb297e07bc0d4e2ec54b8d455700abed08a58efcf173a0d53c5332427b753a63dbc22c94aead073473373778148c93b520d288fd6bd55d47c7ae89275b3cf2f5b6e188b602bedffafa33d601435d8dca16cbac98a0377498b26b867f712a95a2b2258de8b3fd8c0e0fc5092da3ba3fd2febea342d5375ef67b38026d47ddf1abe8d037e4f891b3683242ee4f1f5484a453b66e9307f4446809a68286dedeb87afe0f337d13acbb3c95dfa4f13daafde91fc9bf067a4e565859c8684390bdedec2b4f7cdabffd9b82cc019fd5cc43657eb24879181fd9ab1f2a142889d51012f17f130c1337919579800f7c5b4e611ffad3aec4f0efa937eeebf01dc932a609795c03a859b0676fa118e8964e8c1942483b09da9da54982bd7c87864d21b529268d5cbedb68a0d72b233cf11a6aff925d72ee1381f336a4915b4afe21f956d3355e9adb768817163ba96e5546f489bed8fbf39076f64a24b2acf17743bc722253129b455725096d29004de482b8c2cf4f7fa93e69fcac077202a4c8d92c07d46682f21af80701089fa86bd551a67bd51bdf4ef39bcc81ce6d4761d9651700e1f375d4c957796f6888730a3740a8f7e0db0a583db248b0f6dd9cd4c13a591e148cb26ab30b282b713621bf1ce27803b824b9bc56f3a1defa7e0989652d6988ef7579bf0159e2871afa1135ae81aaafe50c3cbdf73eea76d1d48c62dd8d915f344216528516ca1c3d31d6b1f43c68096da99470ae700086a71abb36bcb3cafe86894390e3b49bc946a9642a3a712d7aa03000dfc64eeb3dad0a6e3381fe69f6b301883691b04b6588e4a02726bacd247b95a3274e3090654bd42912aa8c0a12cc3b3be65ec1b7c645f7bdec121b4c30347d0facba74145becdede37e9a873b429d3251a9826adaad381c5f200c8e5c053ae857eeaa4eee9348493f27f1607f99e8c7785a24a7ac3357f34613f5895ca07c74bfbef0dcc138a4e1415b9ecfa8ca079d133a7348a8d95df8c0051803b8702ff56bc03b914bc2eb0e3a5b78da5bc0c6b91da320e8ef4c53c6a09b54791b15cf186be3898a0969674e99663b48579a2d210a1be27f2a04dc3769d7176c0617ed2d2c3047e35edc43c275008f20d299b5af1bf44eddf1de8066b4612740b39784006a52e2322888fa475df9befaaf7c3079c92c92cd7364bf3483944bb290351a7f0432b9247cb5d427a542949150ecc585132dbb015398f86e92cc0585a9e2ca32a6f5b454f99a9616834f8720130bd2928d5a35941c5a1a5be8f3b3dec144c6163fcf06c229a326e00d37d475615ea13ba5dcfa8db827d4f5d1b6eea4f1367f278033409b03c7faf69563d7931ed4a5f759db3e8063b9091929e7267995bc7edaebe183e6f7ff20d7dc19d0d2c9c05dc05c0ea46b9f12915b1ce0ff82598b5d0d3a660a14390f09160e9c8f3e13a9cf55e4ca7ff6c6cbff47fa1a3c08677ee71fec515d2d25207efc0967a9d66536bbc491d18c843bc63a8af21ad392aeb74e09b8b9d7f1a5d47c7c17fb72b4a2525cf1766b3bf5c9b944673a2c2de1977b43d61eb0a8da19780f0947fbdd6beea92b990a14b28b339f203d45bd6d81d34ca4c3a9da0b106c7e06ed1731d295423a4c954dd30c76bc8405dcf184250e3b22f82cc11ec91565d698977e5d499460b2d4b3ab4b7ca43f11dfc1eba9783d0fc05f47888ebfbafddd4dc18b3096b63d01de88052fbd883eb4949782e483293c54d98f7f236b7906a84a582bb0a6e189afa2c1b5dfbdf747e46c8be81954553879534a73f7d5ce95b8a91e2c4fac0ad21597f71baa0be96fa04dbd2eb5ab05016c9e2238aa6c450436a4763f0833db85b7ac9a1208e6b3bc761fd6e587ad369e559a8483554b55e3537a47dad2ae601dead0456b64491168dc6fd4b88c17490826967167d5a7031ef89ea70b3627b6d0024bd8096e5917f1ac86ae509c70f395508249391d3667ff7d8befb9808824e30806dd997d06680d4db75d5553c4a915cf40c5dd9a19bbf63a65d8f65ee0897f4916fb26cae5a94c2000f1d5b93667633c9dd6218a6e34756aa34e28937e70d3e42e8f3e9b5611c7a6814159139195a77df874a3576c3437de297f812efdf1c7c4d52dae043308f6e261eb09b8b20869c683894660314ffeff692f3bab4245ad8b0d7d0a4cbf2d93d718a2f30b221f7b89d07a77226315be51fcbadaebe3ba9338fda14f5cfa2135286241d8c66d4bc814283a68d87263536fb1a6bb00000d967dd882d1cd245b0e10ce54b44ea721ab44d660a2dbf9540a14acaa3d9fa5e14dedaeeca9c0fe69d7f3090c4c7770323e66fd29033d682adb66115efeec070fe298048020ab64d45e3ac13d0f141157bd30e9321cfcee92e8d0b2c0a219d3cada3525428550af1cf277eacd380f18612f1c0359ee454e8e07f953185b8911ef","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
