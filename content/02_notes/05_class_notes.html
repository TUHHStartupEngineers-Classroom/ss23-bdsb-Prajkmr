<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"c8474f975057eb5f881aef0b6f34eb9db9594c9d33628776eff5411623ca35b24b6cd5165be8e8b6306ecd956c29c48e00a95fb89ab7d39b6b5fdcef7520f64e5785ca3449c120f354bf6e5c8c0d60653c03eeee3543ab16b2ad89448461d12727b61e7bdbb8ba00732bd6ac57e436bec18a4f5e21543030074b5a4d9fe0723d047a812f5667bb13094794ea2c554a824233895b0e73d10e0f202bf5a7229124681e77dd7a58a8c460b2e6e8e89de116c000ef0f9bfe0e88fb6544042760c6dddb6b4d404dc7d9d425adff6375f838cb4cc6226d11d92ec600048688d4f601a838a4ad0e59d7a51c6336c0ed39c1a47d551c7a1d1493afd1620e02703bc258b0f7c3ff68ddd23dec0c6a42e12ebe55b14fd2f8dd72055960ff56bc339e6c69808af75b4ad5122c00e0d3d28e1eb3ab9050a2c296ea2d8def9e425c8334fc1db2eb2e0a2d209abef7f0df93c11bf6b0754006d1ef82f83dfdbb6ea105dc060c7cc745834cbcc6575c9a28952b173d0fe774eafb119d54f6530ae0b0186c95f014d1dd15ee151d547a5f5f80974ea259a20f4311cae6ad1e63dcad0dee4461b473616552dab7d86189940fdf7ced0e65b368fb11ed2b4f0f2c788a8c7566858527639ce96d094ced5559f955ee9ea60323fe34b8051ad48283bbf866532864c86452d04d5b48860fd887c5fa0bef8ed86b31eb42bf329948425907fa1284a457c8c2caea9b7abf2eb230b9a847ead8c71901fd5ebc4cda8b3042744289e159059b7275ef14c42a1bff1751d08acf8569e996d6f63d4753d298612fa0bbe5336d209fb7f54cb9e7ef46a441d5983b117ecebb600e8688a7ae54074482639245ce17ed89fae2e1389620b991797ca6c2574671a88d895ba5be05eef0fbcd7e448cf71b2bf34a2232984bfc5d5d5b9bec8f8251a5a654e19d86ec2d2f8cd76ac4088bc3c4af29f1313703d139dd1d6e1b2b12a4f726146120170bb2748987bfb9dbb31ec4f3ab4c5fc609e260d6043ca1f7338555ab339a2c3e09a7dda760e87d131b5d83d901f4b2f11602ccbc0ac1418c2610c0ee0adb79e619fd4ea9bf36ee2ce977ce80bf0660dc25e907bbf4de461d6954b8b088aecc7f69adfa9d9871a224811c64da274cc1e45907af9555cedee0b5f4b7fe6ccfc478aef8a3515035d0294df6894c9a8dec421c8a6e1dc997a147838e2d973cbe36402f03411e1b37477e8bb65a1395c7f72ad248ba2d91989bc99f572c3195dbff350328b450ad07a3a3c2bcced17c6caed7cb0ae9484b6bc44fb8ab9963f394446db3334e66934a6c2df0fde0c1e220c1d4ba1c8c80f6dbe8f8f96baf8d7f4a508fe1930abe6a4b8036b9cfa991660b65ecbb100ed7bb4b7b5a69216a1505b1d7812821dfc9d34b14ff7bf7cbfffa8021e21362e4447cb28ded7b8a27b6f219fac41d31f190a5335778a132ce58b54b9f9da65f58ee4ed6207280ab8f1400d138c4931b1b46454bf5eceb6354cbe318180ec7bb12b8b6bdac3c2b81061b5c0cd1397a5b225bf57d6d1de7709ed10fc17796f67647baca5d6288bed289e720d59d4dd295b5e879a57d2a8ba182288d72f331e61cc67c24f67da85ce3a5fb87aed817ea819829736be3b444f8461d7084d83e6263fd5d43da51aef0b827d527211a02d30006b940a12e8130390f7e60a613c2d5d873ab78a2804bfe557afb8ded1e1722c3873215711a13e05ff2962b8f132bb2138382f1c5e3043dd8d7653cdad5cf82f68ed8a58fcec9c976c47c40141d5490aa8f1cced81c20f2e830dda287efda47a64b15d516bcd797de362d5540cb29b93e58e01d756f4677977725dc9dce37a1c193271598a07c685ed9d40c240d8796783f66a42da36e754fe022453cc44eb2216a66ea1ca8421dabbef2972dfc3abbf5ef28aa2e6977c36437a2734213623a6217bc269577da32ee1dbfbe1e3fc9ab52bc36524246a37218333a9cb31a2497abfc89cd88ba839f48dfcdaf6b67e02e5f60111d12f09aea4362785244243187a5ab209663a198cda711a55ce9ae93a8d2c2a3f3dcbed00e0ddb4becd1dda4022b22c29f7a4316f07347666f3a8a986b1ac6e46c265580e0b7e9f445030ee8d46f504f9b1c221fa479bf1706aaa3a6c49ad905122f72b532a011259f3e9d2474dbc2eb2a9571d46da2d3a423434c2a6415515925a42a78a63f47856b92e67f502dc14c2bb1217ab31de6d57b709a19e7c791648dfaadf377c901935feef6086a2bc14f48fbbd3ab18abe2e56e11c040954c69c1b8475eff85fcbf6219782428b8cd832b4a4bec0bc80984e9fef355ec6d55fa3ea11b15aaa9910b9730cdedf86b84f29a1388aff228db26652152775524fbf1fd2f391e2ff2948f5977523a17c63d0ddaa9511427f6d93e19e8c0da414972a33de26618826236e28cef63a2583befa882c2e79dfc813eb70f65a7541adb0c069041c37bdb149c5de6f2fef8c6dd00e47479313bd50864f87bf984d090cb1e009859ba6ddb24c09d4085f9ff4fd3f38060b97eedcf49ad3a547fba3a052bab219cb4f7c7e124399709da22c769995e2427dd93a4aeb2339c8d64ba1d0f2d26f828db90177040ee7bfcc6a308aa40c51c65c6cb3660e13a1373b0cb468538403e1aef51b5944e9d49358274c23a8cf61a98f8f4042da2ebd8d5f77843faf6e1fd53093ec9696e4cf1f57c182c99a942f33fbdf31d0caeee2d458edb8f89060206f8016bf01e57b249d6e811b6d20f42ac8a094f56bdfebba3cfa00451ca9f1a447ebe82ecd851f8d2b0126aca49b6e17cb22df2ac91905c5fe0d153e8b6ede84f6ee623f804e85db80a43ea6e36965aa328f7c040893b672d9c5ab64a0aca1df374939f524acc8669a2e3d0e6b7f44f3040af378a21dcce74807b633c9588f1f5526e8dea8bf667ab7da4e88ab2c522a642a74e186327daf48bb52f3a4376bfeae865dbd647c2b5d1df6a487ee8ffb28ba37f928f4d0a368b083238a96a8029a8f009661f82b31c6873d1430f7a0b70713af49eb06315beb8165295f5c77af24896b5409705b72f9c75c32a4dd602ee4f48704caf2651046b9532441771400bf21597e9526612c2fe53e9831a7b7dc906891d2062409f01d4634c221ca586630222e191079a3066142c56be5e0d0b5597cbace348a8b99de278a12f6ece48f41f7cac4865390d2326139d1e16576b53da2713304d785cc01423110a025401147dd49ff43333a957dfffde95f56fbda7b9ce3c0e45fcd3507337afff2ff0635d9351da91bb26d1250ebde52e29171144902133972cff06e68c4ede50bb1d29a9264fa7ed7a307af5cc1be6fa6d16e8017649a9fc921f5cec55226a3b85c79739f88ed55ea7ad622b3802f6ed433656e1bd5532999d681a52f9194337ed4df29bf7b6dacdcd4ed1e37a337b87e06d3587b1ad42c70ca1643aa1fc4526f5168d0e77ee68b2e96bd4911541e05b0bc57aef67c05df9238f26fa9067b5d7c2f11cd581a6d4185d09762f3815f9e07af017b73164d57f79e889708ead5994eed220df4dbcdfe0452a0dc8cc58b3114874031284b17d295fa1fa8aa4ab383cce66f248f43d94eac5f11fe53b269850dd968d4103d53c8e15711bc10340c26cd9ba20ca60a05876ffa690b763a52180cc5f40a140cb180dc8701c5727d04273f6fb3d3a8434ba660ab35564df54d134cfcd2a30361aaa23f37d45b25280f8abdee5aeee362f61ac2a9a7c2fcee22961cd726c7b1ef684fec210a2f66dbfd0c1c1877f83b6bfe0ad4fd585052ddad56d25b14600d7a0d1d5852c0cb87fcf95a6013660d363f9379be6af5990a6b9308b2c48be8d7dacf7ce3ba53f6055ebf43e362df7b8da9f068f24ad4c98804144d28106b8610e359e0b9b207f9615e95f818e0a3c8ce4ed73fd80eac957e6339ad6d5e786477f27212e1b6bd1f95af6aa723bd01f6a9a4c5b9b3ad869bf917c33f24fe862049d9c138ad75558cc69bce300d36e3a49e6062ae5e2f74cbf8ee185a745dfae0c7262e68e308ac74020eb3d9079105de77a8a7bf21dc442e3425a7f9b8c8bce301792876550aa7873290bac7d2a020ed6c6386efe416b5bf3538e9be24808e91a30efc66b49b44afa0ff4f274c8b897cb0fd2eb2fd0c301ee900dc48bc1ab4a975562ba470ffa21abba57d90eb622fdabb16197cac49972ae91eaa825c2a6aae85a45ad51e348b532a90c875c625ed89e5d1d8bdebff3beb0cfdd2503cfb3a691382b66d576721198a6ea151566b11d25d53ca3976143d1394dc2bce47eb66f9f4a6ac97b15dc1f154ae252cc204c4016f55e96d1f0bc140cf8ae14f42fd75492fd666d05531796efad327ece27037dcb3a73056734f56b89fda3928b377216c0dff5c05832e6d2039317b0a03dc82c4e85e3dee693a80d074cb203fe6d6204015141f5e767446f01b1b00fbaf6898a6573d30a8c1e4ed855a5dd6551b400a6418110d3b518d3ce0acf5475bdc05dac932a775b7adfc474eba97e19fd7015412620c7d51a8ca4eb8bbf8d9ca187945e5043e253f34b1b427ea18904374652c8d4787f38b7db3f5eecd1b6ad829af49ca54c897d9f37a67c352f97b56da00df1e6cfd2726c9ba3ce65a3d6a3939a30f7e3f04f6f8a66b9fe27ebc841a4a1a438a91254e549aaf30bd8cde8df0544ae56b768ee82621bb4355d9dd6b3dbbd601ccd3d3012257b1a9f36fc2da37655b86541f904670fdfddbfeb871f9e6e2039b5068b4946b4009c348312f7e3323db0756c5970dbacae69b8305d3bab23f84e9c67e63aaee5da1666de80fc4238655522f2ac42b6ef4c3094497db5d44eef9b30c3905ff4d19a3447fc3943a4f7704bd0660546c949c9382faf25dbd89c555af4a8915678e1265cae67233c0b6d97428698c262556d2ebad392e4fc3802c15d01e1bcc550ee1b7f889caed4079b7a6e718f1bd7ab2aab85b4fa5bd83247d204de6f86ccf00b22ddc0df94252e9d6bdc4a93c3a08d33442e1c986306e1d1dec19f41742d384738853d668463e2d69b8189d15c4f2cf310d0a8094bcefc881bf4f038819d1b3380b5c606be3da0b45dc286c14d17bbe764b28f4f5580c607c856675d85392c24056d84082ea4885a67e05c830e30607dc5f445b276940b90b16b80d70d901a6a3ece3ff935b51b6ea466fcf8afc5586953b1a12b4d23d500d624f9fb22ca541d30ce9368f63d4331149ca5c9a1f1f03d4ed1caed60332e9e2f5d226b5d4d4bf4e954bda5b23621342b6e2726e698ad5a64fdf2e9184562378e21e92e12e211c84b8ae1340686a6615ff736d39c52f6031fe941f6f589a8da418fe4311ab9d453328ed301f973a2b74f42692284f425557420df364d1bbadaddb8a038480a6d141dfa165ade32317b1c77f8908429364f4da6c732cd2d1d29b719589c547bf70047abd2ef5b447d91251dca75b679ba72429f76f1c44433a4c6d1b0bd2c33892d95dd7d2a4302cc818f41a93a3ee28bd54b120ca045cf292731df3ecdbb9e99385b804965f30c702793ba07770af19c5490b36ff986c5ba9749b1e6427975aa1f7200b40a85340af9a9d647642e8824a67c15ac2e6a01ab3cae337c799e1faf8d08f12cb8235cf970dd9ff22d580425666e39644bbe9328962b8e194f1b5e05fc1ab15a9965ee52e38e34aec465d4ba18985cdf8b6213f993f6f86594258f837aa5394f27b11efc69629ab7e44b1701aa9016a9576246ede2ac406922e40206b91c2c471bd81cfd7b4333a50d2cf87270a610ad15656f7799a3b1c6bbd603d1078b8f7f68e7c3fa972c20f0593fd3899f36362ce7b256aab983d538d602411493f86b8560d5914f1068588f052c60f690eeb5f1eba4ed6f6ca5770d7621e635d021fe2c238239a9489f1d7bd2b76f186868c7460454ee0f4797c186d3c4564dd5ea4ff8e048e8d06f250eaca2627914673e0e0c9f0af9e1af1b82294a29b79dbc83b78b39feabe0c7b55b9e602617964b7c6201f22f581ed152304d4cecece6fef47bd87d6171364eb7e8296d020d38c4320b5d58ad818f347287f63574e1e6f5863e90f394460c652f3b4dc72df7cd4204eff2571d42024820fb837e7a438954978a8472fcc9819c72d78f38a5cbee8027eb6d34e94cd8f079908f64fc14a62777dd3850885696a9f4a1d69adc13cd4c638ffa51ed2f69238cd24bcc064ba69dec457ce8c4660043d7c2d6f2425b74599186ee53786dfb0ee4eceb4e5b1fbdeb1d7678ac4761e843512cf2ff6ac6c44f603f5018e5d23beb0948d257d03625479efe56aad3efbeb39ea344cc060a052274c7b0a24806cb5ce7b5f39783bbd08530aa7e90cc7d992348e246fee54a667f7915c38e4e9e8cdabd5487586341bf065c9db2c1f44d556a69ac9dc8f2495844b4c13fa63baecb84e9a75cf7712d54a4c78bf8ee63a036f30962c0a59be2e78892e7a28e3b11ecce083fdd8f112dde8b8f219b9353e8e4c3c6c09720cd89f33f38f85c1c3d2e0c71faac579b61b5eb37c2d1a674990f3189a67997802f86d0a681cf7ff9ae769c75d8d7e680db99fc78cab5b52100c5782d0283af82799163fa56ff92e01c35b691911070481ed1f4f81a03439183ac869a249d8c1b225b7c46b662c9b2d72ecacfab16b3873df25c9189c9b7a81d1e41722cb564f79aee081039a94fbb1a1ce3e75a13b139924be101a65df198053103a917386c24d0daaf204b29db5340f5d2a8a2d33dc050620dfa6894c7c0a9742556777a1210978ffdd3e1692ada949fe92b5c28280d2d412c4a60bda9a227a04d6b56918518623d1faa733673ee8fcc6ee45aafa97e05ba50f096926c78a0fe51398fcc11b4308af31819a408d72537f3b4759cc5ecbafc27bc704b03f621d2851a190901d5f7cf037c9b44a24d1fe3cb1c5510395f38caac565878ed0a0e062e0f3413008ba9f03792089243a8f734f41976dec5ac1e1a55db6b64078f24920e6d3d341ad33ff31ae580ad26036e8d1f05fa8ef7d286fdb8a91ad08cdcbbdd47d5242a6da58a197ea3226605afef14fb67a6022394d47efbe6f9bc77f3c6e29493ee8eafdd8597fce0d19e2a250f235d11e571a09ea4e329019668e3df52413b17a39a72fea94c07543066527c679240359ec8377f1602fb892574e7769a3b90d691f101adb7ce1ed8898925b54f80d2506c336fa6b8f1894aeb1fdc13bf44882120a43338b24a057574f17d61aa51ae23c3ecbb2124cbe5f042bf6ffac91505d83f66f3127143bf5f840b8aff7be6571034db8731a6c91d1185ac2410462193c0df7e1683219d0ffe6cadd00ef29e42585dc20ef3d7efc4d7ff7824826fe94325661b79232d13f81b99691866ddb6bd2e204d3c87eb147bada94a322551657876624732f6d13bbdda4d41459d9d311a95693bfac823ccbcab901b1384b89a32d8cfc796c4d688b6095c932771f77a0c109338b180dc5cd20c6f5a128397bcc561058af13fae27ae2c38a4adfaa4c473f215e5e38f0ba6acebde3ee517d57f8c8c42879f18ab826b5900a78581d3095cd84e7522101caa2558ca78302cd8d1dfa27ead1069055761e8a276ba568549fd819646849cd0f73fc370965d0a7b81d6c03439823475b87db665f7f1f6859d16dc13707f94b9add61ed150204c59ce33601b7b89744fcdbc32ec3cf6f1e2590b6620da5b1bb66078616b008f47c2db8400431817c5fdb3de14d30ef45f442be8163221f5bc348f55568008f8ec994d939e4f11e23f8ef085f70674b5dcc8f97689043b767b295a79de363aa44f6047d0a52ea9264040d4122453f90e67d65bd333bd158797aabed2d0157d297302e4231afc220a48aaa4b9050b3fa1efc0b4dc6518c01e384adb25a9d1e180d3d69ba2dcf295b59f52dfa2bda48bc55f78317de124556c9a5d0ce6e5f2cd6b95625eb0ee19256c337e0325aac8959126fbd7fab93b2e35f0722d8e67e9619a246d2cb70d5ef415f60d05f574f7264945c8eff6d1ae55f2a9ed76c392d56720958bd78dc0a09de2597e421efd6d6bbdbb94874323cdc8b7b01020b3a7d7a5ca79bda008b6ce4e552bf08eab40fc7278a29de42333798a1ca4ccf6efe5ee5b6c11aee0fe1cb05227e93ab88ab3bfdb12ff97592573f4084b9896703bf347d49bf4a6baf446f472caf6be75d47a7b225af5d266670c6f0588491db8d2a7d2e3fc0632e2d0936847c59e1c852860c55dfb96302959bef892552d0eb616655cac71b9e885e43ce164806346cf50e56441b6b2563d3a6eeb4b719ccdabf126c42589e255fc3643d12c60018fed7c51b53b444575b0d165e2290036b13efc427bcda289da571cc2f69d0d829b57e0bd220477de8e0222d254603e7b2207afddefd37af63d60df479c6a8c9e48077371e7d9fcba89e049fe51dda1e5c4f1a417c09a8cfd280ce56283f5a0a01c0d1c0e65944cf6cc3c17433791762e9eb52e6b42ccf862f7d18b86520f0bfa7f667661af354e59b6e1c9bfb754b32c4670952aafb2391a8693b3844cf80abcb8b0bdc6b0018b8598b7c9e411c41a8e1166541c522718aa870c335c531f691d1363ab7b7e9b7052959d255916b3f5f2249afda5100f75016b288ba31549fe48cacbdcf92cd7dfdb7a5873efadaaf5f36077c7fe4549105e1078ad21352037c383ecd5944f49ae40912272f2ef9dabcc766a8bab11c18b437654c62eb0a5e791b2b541183db7d06d6459f0ded41fc4655c8b63c4f4104d2c52598608e33c1f894bfe79b3bcbc06455806b0b99b02a0a012ffac8a3aab6f6b2e372b2f2af9e37ba9cfd880ade2723951a4b24096c89fc2f1979c326672ab1c8b621c0e797b2ac58f833fb9b874717210020fb1976ab1c786b77171f36b0fe03ffe01f45635e0c49c5b7c963c7b80243529dbe689f1b8da2dde26e3a6433ac4bc84f544d1f686777b18afe58a75085cc5fef77b36e8796e88c62a490720670821a1602d4de8d64d7e3f321eb2bdf311a256751b557f02abfd41136e92551ad5731948c1aee8499ebcd02747527b02d20c4f20a639aa2872f5b7f882467d57630329bc1b9aeddbe320ff3086a34096b1a40906f0d250ca4db9107e738091ef90e55b36695b030e3ffe0c3cf5e82233e5a1ce9ad9456d30d609ded62e9becfb23a3351e953a6b6cba0f866f17907594efb6999ac3ff7cb33a55af46d150e8554ade7d13a78ad77b13a2857a296aad8b0d2b5b0f138340a6bd034b26b436bf29f80fb0cd8f02a27359df5da96a4a2bc3772149ea9e8dce7bb2bcb19dbd8ced01323ba30a7582de38fcbe71be5511c50ed5b277812d2968670d33759f597c401a68bc0263faad4e61a6b198b6053280bea198f1f6bb581d9d1230d5d0790b04c3c65a78741d5606b7667c39f21bdaba3308a2ab0a93b6f4c377f611db055b1aa45f183f5e5f5a479f2acbf18782c8aaaf2d175acb1b31fb8dbadf62d987599e78ed40584f9b91faf5dfbc9deb89ffe096c97e9b791ed75803f3af942bb733d44ba8f2e9dfbbd2eb9345f5970341c95156ea0568a364cb5a5313c8c54246669d4f10c4e716597fa30860065fcf9dae43cc423062cb63cb3c1d06c843ae4ac0fd0ee41c7ab57326409cb2af78997d35703948a8bf01fce1479daab439b56bb4130900c9bd6670626468d984f0e4a63da07b92863581c26d28620f3295a209fd287b0c17da3cb02493eb744f08713525ae959e3e5b447bb3e21a77f79dc8c5ff19f48d406d74c7752c9d3ed2ea6770216cb178f2bffcc1bdf2b8f09e0daae17924317922e6360a2c4e2d690a9b8a7512749115d2480102e1d190b295e67f6238d63d61a172df2917f40e7be12668e55120d34a286a7808e04c6b0b1d849e724cee0c34327ef926114fb5070327d602af7613abd91778a28dc138d6b913632c55a151fed1ddd9da906a133cb06308806856e3ba476ddc106da832bc07f73f93920bc11f3a2fedb8b7645c47feda0626d433a95d6b9dc9fc4167d134b41ed28a7c7df6df1e37d4b2faec0c94d704dc2799d8c56d1dc938d619a3378c8c5b749cc585244fcb2befc5ba8b7228b339a0af33a8c0e43c926f2056a2215cfc27c9e2f110bdceb67111558a38b8750497eee2b3794f7e991c0225a3474d502318365756ff6478393bb41466c14c8adefede7bd2509b61df5d0d65a7c2f3e19ddc171738a485fa0ab605dee8692d55cfcbae16d7f5776123e83574a01d34d0248869a2ed43d6af6db44b298cb8a485ac4f444dedf1d916ec97045a5e30094854b0fe6b89e57e263a76960b2d93c9126a3e59f54c96d426d99840b7e77d5d78c1abec9b5a5a7d27e206ef84e5c6cd23fe8cee2f2ca179e6fd01f26d415147c10cf780125f6ca8de397e3bbbcf0f3dbec1d8417e53a7a0ac419347376601e0034e9a1c0a6fb2d97a80d1e743f126a6d2f00154f7ce785143967982747519da330c16b750d435e2f01ec27ff302d3586b2b38acf5461851f06f66c83c5afacedf74ffa0ecde17e36df1396d816e32f8aca9b7809b20e56ecf344cd9f1eaadb5935d1706542aba27eadb9bf6f439d8449c0124ef2842085fd2129f80df286a9ed9d2ad69a8e15bbb8a7b343cea86602854ac678939288f2c678951e9458eede0e7abee1bc58cbddc9dc87d83ca014e5c45a82ad3f7a981f79786a44472ceadff99a2777bc731822502638f0507b8f297d1deef73a109b62db58b9f67cf0d40623d26f1fdb457bddf9c71de6371a7fde0ffa444cab70ad12e5259c9539df964fc408efd47aa126ab1c2f6c3e630e34696010d06e44c8c4e7dd4530a59bfa0538fcf041c7987375b13f8a9b1289ca50616bea927738aeb9acacc50b1370978ec8838af17332632454355e2575665705180ed01ac7afcc5dde8aec3387d4817661da83d180d1541f8798dbd389e1bc91aade4212b41994b7339efafa0beec30c0bc60d046aec9ba212d699538b3f2f82122d255963cb84d820221786587062c1f585ec30c56b52c656d294b891c9d22b29d1b68387f9b12910537ce25b8df2804260abc35f39a6f874c74cfdef0fd47ad895de25c720186a2613e73e2c6ac68d1c101dfc6047e1d0bc9a1367365a536d480eb72fe549644409bc306253aa578c308939ad184dc6fb663fb63368727225f9f3105f5af886fd8df5e14400a8de1ef2de745f92d327bf66c12b55c6db356d5a013d319d7457f82c8972215ad561cc5cf8ca989880baab53587991c6318575bc7f45daba5770f124c2dc97e33fc28b7a943f207c699e9b1c0533732c179953f3151a49547674396a2825be22d288db98df2b0914d91a883b64bdc844b92da40fe0d16849a03fc37682335a3a13fca198720f969a383901cbebff306db3a5027625a3328d6f5a898dceb335976409a1869cd7ac27a5ac52cbf0bc88a744dd401d63f5a96d3a4a7680dc86619f44f42ec21bda03ea0907ddf3e1b940db90d0c1ec58aa0e8a7f07a3a0765c9334df2d4691abe1a533d3169a95e256b3a24f7c39e5534d9a8133cfdc831dfa22d968ca5cae74920ed81c840f548bd7b13321f44258662f3e9953284320d3e4d7fee87f02c28b1822bf41567fa2481911cc81efcef7b235431524e026e9cb02d022b838fe5410c80a2632de1c3c6fcd924ff7e94695259c2727402770b1e885ed8a96998d84be001b3f13a529fec575d999d0d6ebeba9b60ac82271761555f45e61657d4d7f14e01ff06fbeeb053d4260d6269f9fea7c4a1a5deaa8a0221cff8b90cb534464423ac48aa75c05d4a8f441b18341d5923365e96d6b7cfebbeee9e7b684c5888df661e0f9457f5c95d3773cad00451f99e4a191f799438e170a645c88eeaa0cda2685181e5cdfc8b758cdc3179bac9e63b25e9d35bd49ae21ea324962c71833fc17f09eea3bd0b639cb8e8b55558673ee2dc949f9d8b338c945aca45f92afe43ab300b0425b16a7f9efe2de8cc94462ad648dfbd71c22151e0b1d8e30b6dc4a03cfd585cebd76b71ac4a879f5c4ffcf3898e29a4e72ee109b7f7ec3494111dff1c8f3b9bad6b9cd356e6a0022eff6443479e7cdce6dc8f4f9c950b5b1dabde541c188f31a8f3851f8b118e297fe5e242686570301424372c1315939397559ae95125a1dd6a3c6abc2c65e954c0ccbe5810f3f38baba3b41553c18017ea5c030be09f4bc12ba917d4b8b3ee81db4beee5756f9745ec46e9be53ec46ab6062fc3265b614dafe857c1b731ba4d5c042de491c4bda619deddac3df623fba211ec8d8ff511e591a633d56d2076ab540c711e98ac5c70933cc5b1cd4b339815a5787bbd54c25debaa4c6a4cafc189020ff8abb32621bd94dc21e036a5160b8efa1ff85f06ec94f8cee44fbee489c0a740a85eebb11401b26f1d5e8a035b47d9f0764be4ff76aab3518b245c38a3ef7b8f182d20d4b1d44a0a2049135c0d8e4a91aeffb41c2cf4822d9402a7d49bcfeaacdcc29ce59e3ae6ef9b201f756695479e32df93badb1491665d897cb220bfcc123c62f4fb6e3281bcaf5e9c369a0248fd28cdc42c56c103f7def1c9754b4421f0f336ac716830c919fe15e527a0ee8559b859ebdda37a9d8fb6e7207c1fb354066e5021257c0b5e1ea69ae92e43309f98fa0ea75fd0d81ed4a21e87ec5bc82f2b77e74953de7d96ca248b2769ee174cb2610b4352a5a343f92c4f3bacd95e55e7eced5315440c24d3254d351a8a97f10dd182148c808bec03e821c0a2b4318d21bad7e7a9241a8e5926f44e25fc4093872eb03a2583532a597c7e958b13d639ec7fd3470230e1fb92b18cee54feb905f5ff344c00d4cc8b12863a3f240e4f09ed306648b7bfb13eb3cb0eed7c893cd32960e59a219f6b01a125cf669d301ba33bde4c664805694446f54b49efab0dd55c6101194c3100d5ffec54b8a914326aca2e7bc9ebccee3eb773ca4f3cfe1a804d4c3c369ebc49bd55944cd68ef32c6a555e914381a216ab3947dbd807d6ee11001d2132da9ea019972148a50b53e634907fce54e984a6b873800101d6d838af1ca444a704bdc208b12a414d10bc7c55b305482098b8395346f8f1251b8e1ef0f44cd977a36cf06a526bcdaafdccb1810dd03c40ad9be88f65c2ba25b0535897fd32a5b3ee26bac53e663a810ab63d3e2cecc1f518a237f0d3a91c13aef07a19d3054abab2970ddba7d0da479dd6a2bbe8fedbc3652e03b234bff1d865aae47e20f08dc293dfb0d8ec05d694cfa6e5153474b82445d333716a9fd12aaa153269863c6976c8dc7ad544dd939e6c6220c44ec05a969b1ff6e5f98a5c31124bcb52f4885485c5adf732b09961ee5f8aafe9234f34e3c85f9b11cc0cf79284c3e5bdd8c6f52a33a272480344fc3535b51965a7eead5476bb3a4c9ddeb20540acca2ebffc0b078691a4ff01151e01d668a6c28209cf7d51913b244c865867f567f43daef8f8f37737bf8bb26a0e2a6f5efc635777cf7d572c6f3377946a426a09ab431818d7c42565f87ec5366c65823228a6e90e39058dbf397cdd4ab901466c74122c55054e0ed57245df1668f497ecf0ce0e078ee0a7316fc2cc2c1df6d9dc1fdaa8d3cd9160efd45e03d0100649de7a4b6b11a80946ca3f4794f5f6c41130c0aab1291ec7b91f27ed1db50572c9e2b847bab639a2ac428d68e1a6ec2432437867f6ba526759b89253a9c5a2f353ca1b501132493714b4737f3095ad50aaf6a140e826bf1faabfcd357597a40348192690add5da6cf4575764f4e81a920aa969598bfaa2446bd0e190a0d02f00eead2d5112ef4b0c1402f17acf95ee2c760272866526e75d122816469a6adb13c6892ccad8239c15e84d10979bf857598031e154244a03b748569f9b12b1281297209e1e1815c42a974fef837560961662e3a8cb2ea09784e4c1e258f18c08a8d5b768779a0b3a06fb821a78a5c5be0ec7ae4adaa3b65f9dd89e88f01d081b3a1e6a3c08efb2d5ec27c4262164fb20d045676571484423922f48c7a6e57e475b2574527a6a1ac20477050074cebd1ac9dee93fb4b948400f6ae94c165e2d760f70fbb0d7b76fc76633cc842d3bd01151027497f44dd9e5514ebf4823025f1c47167fe347a4928c3fbcab385e848bc0031dba68c6819f11b95f530d85e871a0f5a5fe508584849daa2a2efb1702db45463a6abeed1e2c5b23fc9b6fe64ebe26113b9a38e32e95f89a976317ac34d708bdfe5991d4645b9a79cae0e14c409299b478e715ce21740a12cd973a897e416acca3dc1de71b4852a88134b08d186370ffe5eb3c653631835b754b334d90b0cfe05097029ae52c2679749bde2a1abc1f35eff9ab3b4fea0fdb6787e8424b187210ef86330168d1faa31ec8e95d660b1e442c2c080a49b8b63a36556256b4c963049f4821bb2499d2d9e4f74dd50f142cda1a6cecadf7b658164075ab3012ec17db0d37b4f5f3984446e7656b0ef351486801f9b80b251db73451ebf5c0e52af514f31315ae8ab0a5fd3217304118d6e6a7faa18acfcced96a2d66f1cedb8f4142c33ac5dae0d2df7b57e04f885474cdb73d76c62a1b386a99a3031c0a2a7bca43153688a6ec4a956c43b458bd115d01aa4c4aae7addad43a73044c5aec5ee15cc87930244cbf8743903ff84908dd1fb70f8f6272a94e046eb2768e314eeffa1dd6876c93309a3e490d892d564d2db48539d84b57d21a10c16dbe4a63683752f54b45d68be21f462c0214f68619e020482e66c1c054c3859de830f6c356bc82292caabfe78998ad8ed0cacbec728fde8e91cf407398e0c597e7cabb921703722a4ef462c00fc55640a9e9c927a9641d301872f42f9a1dd7965e9b1acc3543b2df6fcaf7ea29eccc795fb91aae0631ec40f26d1aefdac33795c2d2c3bcb3d6524f5c3aa6a3007a1d22b86eac4018e8df9c3644b6bef5b8e7a6dc47b8aa00fae39b115558a56f63f592335852c087379cbe10c34bf119ce839a4ca12112f51d1a6628c355276ce803f165236ff09045ef023df4c087e0fa78552e20563de01139991ff5861797d47c8b8dc0b8c63e4e31235003c732684116b20b623fe567df989fae6477e2dac3e07d2fe36e63298f490614bb0066b32d2bfff6f40bc2df5335c43e406c9cd23aaf8315cc2c1641c0e709675fb5e9cef2df3d2a25d8aa4e4be04474de7eed7c528312cda79086af41f8bc425c1cbccba87efe1dbaf237675382d6bf61ebcb9366c2e39748895745e2bf85c1a6511a4267ed44db3ad06a5ecbe05233e97b2e9db77494bf1236b67c029822633e8078ff790d032d3f04a38a4f22cfc411a6306c76145cbc7a2a218c30a586d36a8c72cfd8a84be4d2eed8a6d97252df2324868f28af5639720b3b7ba17a24d861d835085668d4534a7c2d6508282094771908f1da36eafc9691d1dd3c2855ccbe73e508994042cef624252c5f8b92ff3c1739a700fbd77a2b16e4a5cbeb4e9ffc795066cec9d1fa81d38108220a9cd68d4230bc7cfadcce76586de9bfcae75311f7b1e21adee70bca1943128035cb26e2c2d2ef8e661ffb0b859c137802271962bf2e32ec79bde01c8dcaeb17613f281deabdb068413cb46d7dec0a5ee85abcbd15ae0095d50707ed8b0c0d258b0d9e5b662a8803a967dad20fc56ca7849afbe6eba8233e37d447872e98a28c6a945a2bfacfdb61beb99f37a1c8d6b90922cf3b13bf98af0c385b8974d22074c84069117b38910bd625bb48a7c312dd232f6189ac0fcf6ce703f391e170e5d28af19ccabea6238cf8f1020a1b9434faaf3d7330d255c5dbfd9cdccc370ffd724a5dbca56ad9b57b031577afee7e2867386fdb91f9b3f903eb5d48cd27b2e0b19400bfb4c1d301113fe2e3877794b2c810cd8b76b494f24bf91a49e60cd6b470c2369de8eb302ad404b8fa0267063dc6849b83828ca420492c71342bfab667e138c2716ff419a1605e68bcac1d80647e1b6ed5c849d8e70968abada6f4ca4b151b7dd210aa9474fa1dd714194b84b63272b047397246bc0d37f6a33580651cfd25f84108c4b81e07f8a2103023a38a82f055ac5b671f132a8a25201b2026f60a0cae51440180a836f248442c1ec2de4cf3243721a99dcc12f8fda22b3151f3ee573d49d180cf7082f68613276ff31108fee8b7f4be9dd89f0bbb5b7d55f5cb7c7dc1f3090f2fefe97f247eed48881b5bc032348f0cfb1ffaa278884c92907bc71acd655a66dee9bd12383b6a8235132719e67cbf8d5d5cace61f6bd7618c0b592c99c5baa9330d8a530780a037c956e80f8d500d1908e3e3d62f348c5aa500bd71e828ec0e13dfd5d0d391406a42eaa1eb250880281b919a4322cb76942826ac4830eda0a03ee8df08f34541231fd1217c277a7598b09bb4f9a0bc8198bbade4ca50638750c44367e38d3e2caca0780f50a39e98450438d9c951fba3c27d7a6f016efb3b02769ffe3602b406ef545f6953e65b0807173dc013b4dcc38d5027bf8bce17ec1584c0735f8ae252e5f846d81914622b93c4880ab88e7a3b0c9bd802d441d360fff70997830bdbfdd554b7f6a95ecb3f03a90f0938a5610f26b9f787684e5d81e225e21d30ecd82bfe558d554001638107950bc81dabab269beb7a00b1e2f6c7dbc6d50d0cb5ce335f1e466ca3d0fc4a98b265d5b26584dffb4aeda799f5c690710da7b3f24a26e531b7573eb0e65059e3a63719a03f6c8d1451145c4c5e7261bf917e7cb89ff3d8badbc0d85617b16d8b620ae0d653809ccfcb89c3c036d2b3350deca2887dd9cd7aa43b06e69d93da4d27cbd3a02ad84264cdc90f761ab71f5c1c418cbe4857030d2813ebc641f40ed475de9de1b2325c799e0c282bacc64fecc3a05cf9c0f09f92f4d3008e6416ac6514bef45780dc55a951e0379abfac492faf57e3972d3cab41674c471deccdffaabf0babee87062562b2c55fe1bf5a7ea8bda7e5ef1b60dbd32f3d54e8d7cf25c13b66ee0144cb332afed14ebafbca81aec9a8e8325ab9482c782060edb5330496bf26f92b157bf60446d45e21d1675d2427e7a7eeade276c0f0e8dfb203ec82254e185a090d8b604a7144d3f92537a7fd9a6fa4f7df45e15b94df042bb9acd27ff95e6abacdd1e0cbf40cb21faeeb885ac3cbbbbd5cd00048ebc34253d83cf7ee15f95ef6b9170a7bd5963620ad9bda6f2d8b72f4f7e864c7a452ccb00a3661126a396ab05528256bd551118894355ee9c5b816a3a70eaca7b3c9be165dcb27d21fc415b9780766838354969080743420cb01f20f1da2013f0dc8d55a30e025193285e2569f7674b81b47ad0317637a9ecac0d4ed60d86db8d30def6ac47623b0ef2f48a0bd5c19e26c369e108ef87b9401ba118436c7a08893c74639dac2c340dc791a343be05ce54a9c8370558e65267ae6de9a8cc612d70e4cbe319c2931effdd6b3fe45018e9ced4417659d2285f071073620897c7ec8db5dbc54aa4055fe60963e48a50c400614dcb32eea5bac47450ed86709a0f7fcd4af5a1c51aef20f4437437b4b2f08dc58039da7795b96ce5d535f32a919cf4375f9e6aaab3b1245ade482d120e59e79b4aad250501b917b6df496905e6d183188c6739f7fe29c5ffc7bb56bdb8d097553ed5b9b434f9a072ede68d34732b4a7c659e93da41068f9226d62386d17a3d6795ad0a0a2ba4e696e20a836be736c3ee8a68406a1fe1a3665b71c06ffc71d8169981a3d925968d8a8a4e849051cb08294d7c1f3d73caebfd37c69df15cf68349c9a0af152f1f0cce739b76dfeeea218c8853c7f77cbeae0f47cc3da68be2f6f245bf181a3bfe930695552c4d26fcbc85e718bc744232a900b2f311cf26b641efa1f8abda0e1910a147f20dbc8230655446da5f1782316dfdeee52679921fece9ec0e5584f6cbf591b57d26b4fdeef282143098a0369569eeb6c4c1a9ab593fb08f5e06699e885c8c275fe1413aa58814eddbc2b53071f21b4ac3ed1a2d618d79f3bd628558fbbfd8a8cc7dcb354e02d566f77bcb17f98b7161974f5df1c8c1a6fe5cb867fea97e4c550a17589df22d33d275dbb46ebd58243ff368e3c622d4c4dfd931eceb3ad0951c0b480594ab384ae513669ba255e63b1f6f71e9b368f3c44c66bc53d0f0103a7c382dddf053b3b81623b611a38418f94035646680772dd49244292f630d4ab32b6a65b9d6a9cc56b0206377174e9119fab2af5ce31632f5e26132e7c4baaf968ea5aaffeab37f3abd2a87658660dd651d99579989f79e3b9b1b38a5c7648ef9f1761e403d6f63d29a487a500a7a6e64f357cee9bae255563fcc647194459e895273ce2292cf9175aef643af7cb55c0963a72bad1344769ccb8a22444f078182da15c17e7555fe893f53e57c4b6fa0b18aac25e25b0aa6dfbbcea58451d9d7cb13fd64ca1fe14bdbad574546e31faf34931420754afadb60782997d0e0df01c7c448b3f80e2652caac573f650a11d642e5c33ce486f7495910ba5965ab5ef4bb483ebe02bd038b5d5d375438a672a6baf30c95aad81bd5d6f550d157822385c1fdf452d9c0ae1054f023d8b016d88c009307e9a721b344e2153605274de134df0017d6cc9018542e4779febcb17e504c329da260fe987eaa0b26e70fcb14598f2aaf0e6b4cedb7ff873ec23c0b947c75c1c96a762b26f13aab5d6bfa0f8ef0ab8caf95a1a57c024aa2c6e4db1188bc6bf2ee6ce2095af6ea7f1e9312aa76548d7e22944334f8d835ed328a49fc613e3ed82d6b1bfbf1581c8f0e1776a177e0b7eba39ce156a37f109b5fac6aaabd27f58c7abe1df0516373badad389d967d8eeba7c423d96c41220029e54f2e0effa95468b3210dc609dc6432417dd4bacabefb5dcb35671318184030427cb26f1c3b94fe485d0d3a828d768eb22e8bf0ab7b8956e4818e367fa3ae2b67e225f3309b454dc4f59eb12a06760a3d1b9857f063cf2504ca3a21a51e2264b6b50fc95e3c5a1ec7b11592f14bb087658bf066d7c574b50d21f6335336801717acf7d9c1551fd192772e1580c79120b1ba99d20bea08037b6febcf3618280cf6f1f0ba69881e083e8a181c0773e8c69668dd4202ba0300422920f8a4b650e36d7d55c06dd796e0e0cb2b79a351dbf626af099f33ad240aec890c1812a2aed77d62562e0b8ed16a0b0e97ed2d33ebbde64e44edb39e5c693313df3c58a0441f818b055996a0990022be5f7cda9f082edca400190db98279fefabf3f698783275460d06853d7c93e0b324dc007c166f187d7fae809b8acf5888290a3abb34efb8f0be025be71912463ce86f525dfd3e7f3b7f560c3a6479463a29878799be1644717de956f12d9f5587ec5719f159461d786ef78b743ffe51d3d09794daea125e8f79c3e5976333adf25250cf04fae693f4c36c4c1a35521096431cea043faf0308a3f963e11b85c0b56feda30b1b1d4e77d8cff74120122f4fef38bba36b39b626bf6d88dabb802a24b177f8ecf0ec4829f667b45895aa40fa020a0c256b9cfa9b1f571bf5c0fee6a35c642d8d8f6a3c20e02d90648f1dc87a21ed3a9af13fcf10f8464a6a3ebde518dddd4f13dfbc3635259d99ae7bb9ade3ce03126b34d0d193e8c9f251e2d0458a09225d5acd6a5121001e8bda290894c843ec2b02237d3d51414c7b1e46697399642261151e77d4da0531f1bbadb61d7899f9e0ff3ab09831698311cf35a44377680b47fb61fbb2e6efd9d93ec5d528659bb2720b9bcc30876cbb7fb8ff375d06c9ab17a66ace1a009787126401c4edbd5af459a2883fad8d169e08355a715f49a1e2897af957b89aa03ca4cc51de7b8a89b4a430e7b981edb915bb55ee569d50c4d163b6e631b119e7e2244d1697891d0936b8261c06f9d7077406ba815c91bd44238f8cdbae8ee3d5363f331bff889b9fa02bd021285855e6ce21b07e9d7baa34742ff0820b1ecbd01b0d30cbde54bc4c54c92f7471a8f6f1d7021925f5e0a46ac1c5403558d1ce24bd0dcdadc3d55007927c211a4b0613bc06ae1349b962e94a406cec3c10509dd536ee72646122324af03945b0d6e168fe483b987afe63d67f22f0ca805f65369caf6efdf584adbe7f19f691fb4936831e70eba10c454aa89bc9e879e2382b4d9ee2304cf808554820511ee399dc2503f859bb2ca3e866be7d90cc4c0fd33845fb43911db23783d16a28edcec59c3bbcf871b86c743253a74ec47f57a4ea52aa0bdf35ab7f06bf764ea99c1ee6135f0364b1bec2aed9908ebd7f0225a1e7ed7dfb7249c6b59132b597514ba2db3b8ee54f015d9d4c907254a0c796cf043201361ca9c7a87f5ca11a17379399bc2989c615130935da594194df550f0b393ae2b4af41760865bbd3c68c73d9ce538324e570388ec7aea9fe66315e753e93519cfef1a70c6be9935a43e3c30d5a6fe61584a8db70a82fdf78a3ac24ed8ef7b2ecaf8cee30608dd0c14857e87dfd292fb296155f20f0843108f2dd5da2ff2c74d49e56b704f174935d25263f8f553b70a64759f386ed8d24731191437f5a4a9a265e718d6ea24513ed0f1edeaf13d4b14b96c7c37d25f11cdf8d3aed3785064442dac37673fb45e3d9e6907f16f867013a2a84c6450f6dff3d3deed4c16f9a5c03f0d7cb482390e61d5415f80491fea2cea0b5546b631893c0c427d4ed2e1bb173b8099452529dafe5b92d39ec92612f5cea8a40b22e4b4cd8914090bf7173a6eecac3e25cb84f6c1bcde4cb9731c6c901885c7ca05442677532ae200035a364129ba09465277bd5a6aa06c593f26297bcb2949a060e04e559b338dbb6f2dcd293fbcee0afdf4356177687c0fa04c91feb3a5063d22c4c507e2a679fe69ca73cc83ce05c0feccc600855269cf21e4adc70ea8c890ae7836e389f54ff0597968bcc16689e2a810fedc5eb3e1cb584c920fad70b1d69d1bac0353975f222c6a5d026ba88fe6025b51007c8854a40d7db3cf6b4c431a44182d4189d9d7613e9646f48d655a2b8a5ca2ebf8a7e0efc90c9aaa4b33408a0e3a6e3ddfa03f859a749b72f00a1b7387a03e4c24d383738e9f7d86909240a84f82f088921d34df1d0f830424ae459481a3ae538463b0ff440630eba9de5589e1c6a17e69ae17872cd9976cb5aca0c312f6b59fd867607c43d8b861370f57159e1d37de219d12bd9198d29cd3c4b4ece345762919a4f9ac6579040280b66c5dc15d09fe688e7e83a424403d86cc515e451b18df6e63ae81d63c8c25802f504a82bec7399353effc356b2dea23ed8fa8bb27797ca782f60b75f12955c158183cce996e572dc5da935ff10cde9617482287ae556a460a46ff119edfe71c652406f7f055d07890b73235846680c2d83938a19d80f7bd45cdd48248539c060f94341ac2df784324ec575f4ffe772696eb10c628471d0e123b52f4363b9eb1fe94a0fec7aa1a26d8e9b22207415bce04576607f2d8efe315c0609b5e52b1e736bc6ead1ca3d2c4699c7557e0991a435b711a00fe3668ea09b0c71d74c46cc236cad5","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
